
# SQL数据核对方法整理

使用场景：业务中经常要比较两个表的数据差异。

要求：
1. 双向比较，两个表中，任何一表有差异都要体现，包括：表A有表B没有，表A没有表B有

假设，有两个表：
- 表A tb_a 字段： biz_date, biz_type, amount, biz_cnt; 
- 表B tb_b 字段：biz_date, biz_type, amount, biz_cnt; 


## CASE 1: 比较找出amount不同的记录

### 方法1：FULL JOIN

```sql
select nvl(a.biz_date, b.biz_date) biz_date
	, nvl(a.biz_type, b.biz_type) biz_type
	, a.amount as amount1
	, b.amount as amount2
	, nvl(a.amount,0) - nvl(b.amount,0) as diff_amount
from tb_a a
full join tb_b b on a.biz_date = b.biz_date and a.biz_type = b.biz_type
where nvl(a.amount,0) != nvl(b.amount,0)
```

注意：一般适用于 biz_date，biz_type在两个表都唯一的情况，如果不唯一则大概率不符合预期
优点：
缺点：执行效率相对慢


### 方法2：UNION ALL

```sql

select biz_date, biz_type
, sum(amount1) amount1
, sum(amount2) amount2
,nvl(a.amount,0) - nvl(b.amount,0) as diff_amount
from (

	select biz_date, biz_type, amount as amount1, 0 as amount2
	from tb_a a
	
	union all
	select biz_date, biz_type, 0 as amount1, amount as amount2
	from tb_b b
) t
group by biz_date, biz_type
having sum(amount1) != sum(amount2)

```

优点：
缺点：如果biz_date & biz_type唯一，则产出核对结果改变了原有的数据粒度，定位差异原因时要回归源表。

```sql

-- 如果biz_date & biz_type唯一，也可以写成：

select biz_date, biz_type, amount, sum(cnt_a) cnt_a, sum(cnt_b) cnt_b
from (
	select biz_date, biz_type, amount, 1 as cnt_a, 0 as cnt_b
	from tb_a a
	
	union all
	select biz_date, biz_type, amount, 0 as cnt_a, 1 as cnt_b
	from tb_b b
) t
group by biz_date, biz_type, amount
having sum(cnt_a) != sum(cnt_b)
  
```


### 方法3：Window Function 窗口函数
```sql
select biz_date, biz_type, amount, diff_amount, tag
from (
	select biz_date, biz_type, amount, sum(amount * flag) over(partition by biz_date, biz_type) as diff_amount, tag
	from (
		select biz_date, biz_type, amount, 'a' as tag, 1 as flag
		from tb_a a
		
		union all
		select biz_date, biz_type, amount, 'b' as tag, -1 as flag
		from tb_b b
	) t
) t2
where net_amount !=0
```

优点：因为没有group by操作，所以产出结果可以保留原表的数据粒度。
缺点：多了一层子查询，执行效率一般；相对更难理解
其他：


## CASE2 :比较找出所有不同的记录（任何字段有差异的记录）

### 方法1：FULL JOIN

```sql

select
	a.biz_date as biz_date_a
	, a.biz_type as biz_type_a
	, a.amount as amount_a
	, a.biz_cnt as biz_cnt_a
	, b.biz_date as biz_date_b
	, b.biz_type as biz_type_b
	, b.amount as amount_b
	, b.biz_cnt as biz_cnt_b
from tb_a a
full join tb_b b on a.biz_date = b.biz_date and a.biz_type = b.biz_type
and a.amount = b.amount and a.biz_cnt = b.biz_cnt
where a.biz_date is null or b.biz_date is null

```

优点：
缺点：产出的表字段较多，差异数据不方便比较；sql本身也比较冗长，如果要增加比对的字段，则修改的地方的较多；关联的字段越多，执行速度越慢

### 方法2：UNION ALL

如果表A和表B中的数据都是唯一的
```sql

select biz_date, biz_type, amount, biz_cnt, sum(cnt_a) cnt_a, sum(cnt_b) cnt_b
from (
	select biz_date, biz_type, amount, biz_cnt, 1 as cnt_a, 0 as cnt_b
	from tb_a a
	
	union all
	select biz_date, biz_type, amount, biz_cnt, 0 as cnt_a, 1 as cnt_b
	from tb_b b
) t
group by biz_date, biz_type, amount, biz_cnt
having sum(cnt_a) != sum(cnt_b)
```

优点：产出的表字段紧凑，差异数据比较方便；sql简洁，增加比较字段相对更简单；这种写法更不容易出错
缺点：

### 方法3：Window Function 窗口函数
```sql
select biz_date, biz_type, amount, biz_cnt, tag, diff
from (
	select biz_date, biz_type, amount, biz_cnt, sum(flag) over(partition by biz_date, biz_type, amount, biz_cnt) as diff, tag
	from (
		
		select biz_date, biz_type, amount, biz_cnt, 'a' as tag, 1 as flag
		from tb_a a
		
		union all
		select biz_date, biz_type, amount, biz_cnt, 'b' as tag, -1 as flag
		from tb_b b
	) t
	
) t2
where diff !=0
```

优点：保留了源表的数据粒度
缺点：执行效率问题，全表执行一遍window function，然后再筛选